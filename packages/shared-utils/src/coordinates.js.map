{"version":3,"file":"coordinates.js","sourceRoot":"","sources":["coordinates.ts"],"names":[],"mappings":"AAEA;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,WAAkB,EAAE,MAAc;IAC9D,OAAO;QACL,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;QAC3C,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;KAC5C,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,UAAiB,EAAE,MAAc;IAC7D,OAAO;QACL,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI;QAC1C,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI;KAC3C,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,sBAAsB,CAAC,KAAiB,EAAE,aAA0B;IAClF,MAAM,IAAI,GAAG,aAAa,CAAC,qBAAqB,EAAE,CAAC;IACnD,OAAO;QACL,CAAC,EAAE,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI;QAC5B,CAAC,EAAE,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG;KAC5B,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,oBAAoB,CAAC,OAAoB,EAAE,MAAc;IACvE,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,aAAa,MAAM,CAAC,IAAI,GAAG,CAAC;AAC1H,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,mBAAmB,CAAC,OAAoB,EAAE,KAAiD;IACzG,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,aAAa,KAAK,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,cAAc,KAAK,CAAC,QAAQ,MAAM,CAAC;AACjG,CAAC","sourcesContent":["import type { Camera, Point } from '@whiteboard/shared-types';\n\n/**\n * Convert screen coordinates to world coordinates\n */\nexport function screenToWorld(screenPoint: Point, camera: Camera): Point {\n  return {\n    x: (screenPoint.x / camera.zoom) + camera.x,\n    y: (screenPoint.y / camera.zoom) + camera.y\n  };\n}\n\n/**\n * Convert world coordinates to screen coordinates\n */\nexport function worldToScreen(worldPoint: Point, camera: Camera): Point {\n  return {\n    x: (worldPoint.x - camera.x) * camera.zoom,\n    y: (worldPoint.y - camera.y) * camera.zoom\n  };\n}\n\n/**\n * Get the mouse position relative to the canvas element\n */\nexport function getCanvasMousePosition(event: MouseEvent, canvasElement: HTMLElement): Point {\n  const rect = canvasElement.getBoundingClientRect();\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top\n  };\n}\n\n/**\n * Apply camera transform to a DOM element\n */\nexport function applyCameraTransform(element: HTMLElement, camera: Camera): void {\n  element.style.transform = `translate(${-camera.x * camera.zoom}px, ${-camera.y * camera.zoom}px) scale(${camera.zoom})`;\n}\n\n/**\n * Apply shape transform to a DOM element\n */\nexport function applyShapeTransform(element: HTMLElement, shape: { x: number; y: number; rotation: number }): void {\n  element.style.transform = `translate(${shape.x}px, ${shape.y}px) rotate(${shape.rotation}rad)`;\n}"]}